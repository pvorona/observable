import { observe } from './observe'
import { observable } from '../observable'
import faker from 'faker'
import { createArray } from '../createArray'
import { createRandomValue } from '../createRandomValue'

const AUTOGENERATED_ARRAY_MAX_LENGTH = 10

describe('simple cases', () => {
  it('fires immediately', () => {
    const o1 = observable(1)
    const o2 = observable(2)

    const calls: [number, number][] = []

    observe([o1, o2], (o1, o2) => calls.push([o1, o2]))
    expect(calls).toStrictEqual([[1, 2]])
  })

  it('fires after any input change', () => {
    const o1 = observable(1)
    const o2 = observable(2)

    const calls: [number, number][] = []

    observe([o1, o2], (o1, o2) => calls.push([o1, o2]))

    o1.set(3)
    o2.set(4)

    expect(calls).toStrictEqual([
      [1, 2],
      [3, 2],
      [3, 4],
    ])
  })
})

describe('autogenerated cases', () => {
  it.each(
    createArray(AUTOGENERATED_ARRAY_MAX_LENGTH, length =>
      createArray(length, createRandomValue),
    ),
  )(
    'fires observer immediately with all the values of observables [%o,%o,%o,%o,%o,%o,%o,%o,%o]',
    (...values) => {
      const observables = values.map(observable)
      const observer = jest.fn()

      observe(observables, observer)

      expect(observer).toHaveBeenLastCalledWith(...values)
    },
  )

  it.each(
    createArray(AUTOGENERATED_ARRAY_MAX_LENGTH, length =>
      createArray(length, faker.datatype.number),
    ),
  )(
    'fires observer after any of observable values change [%o,%o,%o,%o,%o,%o,%o,%o,%o]',
    (...values) => {
      const observables = values.map(observable)
      const newValues = values.map(value => value + 1)
      const observer = jest.fn()

      observe(observables, observer)

      for (let i = 0; i < values.length; i++) {
        observables[i].set(newValues[i])
      }

      for (let i = 0; i < values.length; i++) {
        expect(observer).toHaveBeenNthCalledWith(
          i + 2,
          ...values.map((value, index) =>
            index <= i ? newValues[index] : value,
          ),
        )
      }

      expect.assertions(values.length)
    },
  )
})
// returns unobserve - calls unobserve on all deps
// starts observing all dependencies immediately

it('does not fire after unobserving', () => {
  const o1 = observable(1)
  const o2 = observable(2)

  const calls: [number, number][] = []

  const unobserve = observe([o1, o2], (o1, o2) => calls.push([o1, o2]))

  unobserve()

  o1.set(3)
  o2.set(4)

  expect(calls).toStrictEqual([[1, 2]])
})
